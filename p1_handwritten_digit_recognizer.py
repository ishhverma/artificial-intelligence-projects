# -*- coding: utf-8 -*-
"""p1_Handwritten_Digit_Recognizer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y31BZVeSYVXT2NSA-ETkH6xufEcLh3_J
"""

from tensorflow.keras.datasets import mnist

(x_train, y_train), (x_test, y_test) = mnist.load_data()

print(x_train.shape, y_train.shape)
print(x_test.shape, y_test.shape)

import matplotlib.pyplot as plt

# Display a few sample images
plt.figure(figsize=(10, 4))
for i in range(10):
    plt.subplot(2, 5, i + 1) # Arrange in 2 rows, 5 columns
    plt.imshow(x_train[i], cmap='gray')
    plt.title(f'Label: {y_train[i]}')
    plt.axis('off')
plt.tight_layout()
plt.show()

# Check data type and value range
print(f"Data type of x_train: {x_train.dtype}")
print(f"Minimum pixel value in x_train: {x_train.min()}")
print(f"Maximum pixel value in x_train: {x_train.max()}")

x_train = x_train.astype('float32') / 255.0
x_test = x_test.astype('float32') / 255.0

print(f"Data type of x_train after normalization: {x_train.dtype}")
print(f"Minimum pixel value in x_train after normalization: {x_train.min()}")
print(f"Maximum pixel value in x_train after normalization: {x_train.max()}")

print(f"Data type of x_test after normalization: {x_test.dtype}")
print(f"Minimum pixel value in x_test after normalization: {x_test.min()}")
print(f"Maximum pixel value in x_test after normalization: {x_test.max()}")

x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)
x_test = x_test.reshape(x_test.shape[0], 28, 28, 1)

print(f"Shape of x_train after reshaping: {x_train.shape}")
print(f"Shape of x_test after reshaping: {x_test.shape}")

from tensorflow.keras.utils import to_categorical

# One-hot encode labels
y_train = to_categorical(y_train, num_classes=10)
y_test = to_categorical(y_test, num_classes=10)

print(f"Shape of y_train after one-hot encoding: {y_train.shape}")
print(f"Shape of y_test after one-hot encoding: {y_test.shape}")

x_train_flat = x_train.reshape(x_train.shape[0], 28 * 28 * 1)
x_test_flat = x_test.reshape(x_test.shape[0], 28 * 28 * 1)

print(f"Shape of x_train_flat: {x_train_flat.shape}")
print(f"Shape of x_test_flat: {x_test_flat.shape}")

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout

# 2. Create a Sequential model
mlp_model = Sequential([
    Dense(256, activation='relu', input_shape=(784,)),
    Dropout(0.3),
    Dense(128, activation='relu'),
    Dropout(0.3),
    Dense(10, activation='softmax')
])

# 3. Compile the model
mlp_model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Print model summary
mlp_model.summary()

# 4. Train the MLP model
history_mlp = mlp_model.fit(x_train_flat, y_train, epochs=10, batch_size=32, validation_split=0.2, verbose=1)

# 5. Evaluate the trained MLP model's performance
loss_mlp, accuracy_mlp = mlp_model.evaluate(x_test_flat, y_test, verbose=0)

print(f"\nMLP Test Loss: {loss_mlp:.4f}")
print(f"MLP Test Accuracy: {accuracy_mlp:.4f}")

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout

# 2. Define CNN model architecture
cnn_model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
    MaxPooling2D((2, 2)),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dropout(0.5),
    Dense(10, activation='softmax')
])

# 3. Compile the CNN model
cnn_model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# 4. Print model summary
cnn_model.summary()

# 5. Train the CNN model
history_cnn = cnn_model.fit(x_train, y_train, epochs=10, batch_size=32, validation_split=0.2, verbose=1)

# 6. Evaluate the trained CNN model's performance
loss_cnn, accuracy_cnn = cnn_model.evaluate(x_test, y_test, verbose=0)

# 7. Print the test loss and test accuracy
print(f"\nCNN Test Loss: {loss_cnn:.4f}")
print(f"CNN Test Accuracy: {accuracy_cnn:.4f}")

print("\n--- Model Performance Comparison ---")
print(f"MLP Model Test Loss: {loss_mlp:.4f}")
print(f"MLP Model Test Accuracy: {accuracy_mlp:.4f}")
print(f"CNN Model Test Loss: {loss_cnn:.4f}")
print(f"CNN Model Test Accuracy: {accuracy_cnn:.4f}")

from tensorflow.keras.models import save_model

mlp_model.save('mlp_model.keras')
cnn_model.save('cnn_model.keras')

print("MLP model saved to 'mlp_model.keras'")
print("CNN model saved to 'cnn_model.keras'")

!pip install streamlit

import streamlit as st
from tensorflow.keras.models import load_model
import numpy as np
from PIL import Image

# 1. Load the pre-trained CNN model
# Ensure 'cnn_model.keras' is in the same directory as the Streamlit script
try:
    model = load_model('cnn_model.keras')
except Exception as e:
    st.error(f"Error loading the model: {e}")
    st.stop()

# 2. Define a function to preprocess an uploaded image
def preprocess_image(image):
    # Resize to 28x28 pixels
    image = image.resize((28, 28))
    # Convert to grayscale (if not already)
    image = image.convert('L') # 'L' mode for grayscale
    # Convert to numpy array
    img_array = np.array(image)
    # Normalize pixel values to [0, 1]
    img_array = img_array.astype('float32') / 255.0
    # Reshape to (1, 28, 28, 1) for model input
    img_array = np.expand_dims(img_array, axis=-1)
    img_array = np.expand_dims(img_array, axis=0)
    return img_array

# 3. Set up the Streamlit application title
st.title('MNIST Digit Recognizer')
st.write('Upload an image of a handwritten digit (0-9) to get a prediction.')

# 4. File uploader widget
uploaded_file = st.file_uploader("Choose an image...", type=["jpg", "jpeg", "png"])

if uploaded_file is not None:
    # Display the uploaded image
    image = Image.open(uploaded_file)
    st.image(image, caption='Uploaded Image', use_column_width=True)
    st.write("")
    st.write("Classifying...")

    # Preprocess the image
    processed_image = preprocess_image(image)

    # Make a prediction using the loaded CNN model
    prediction = model.predict(processed_image)
    predicted_class = np.argmax(prediction)
    confidence = np.max(prediction) * 100

    # Display the prediction results
    st.success(f'Prediction: The digit is **{predicted_class}**')
    st.info(f'Confidence: **{confidence:.2f}%**')

    st.write("--- Recommended usage: Save this code as a .py file (e.g., `app.py`) and run with `streamlit run app.py` in your terminal. Ensure 'cnn_model.keras' is in the same directory.")

import streamlit as st
from tensorflow.keras.models import load_model
import numpy as np
from PIL import Image

# 1. Load the pre-trained CNN model
# Ensure 'cnn_model.keras' is in the same directory as the Streamlit script
try:
    model = load_model('cnn_model.keras')
except Exception as e:
    st.error(f"Error loading the model: {e}")
    st.stop()

# 2. Define a function to preprocess an uploaded image
def preprocess_image(image):
    # Resize to 28x28 pixels
    image = image.resize((28, 28))
    # Convert to grayscale (if not already)
    image = image.convert('L') # 'L' mode for grayscale
    # Convert to numpy array
    img_array = np.array(image)
    # Normalize pixel values to [0, 1]
    img_array = img_array.astype('float32') / 255.0
    # Reshape to (1, 28, 28, 1) for model input
    img_array = np.expand_dims(img_array, axis=-1)
    img_array = np.expand_dims(img_array, axis=0)
    return img_array

# 3. Set up the Streamlit application title
st.title('MNIST Digit Recognizer')
st.write('Upload an image of a handwritten digit (0-9) to get a prediction.')

# 4. File uploader widget
uploaded_file = st.file_uploader("Choose an image...", type=["jpg", "jpeg", "png"])

if uploaded_file is not None:
    # Display the uploaded image
    image = Image.open(uploaded_file)
    st.image(image, caption='Uploaded Image', use_column_width=True)
    st.write("")
    st.write("Classifying...")

    # Preprocess the image
    processed_image = preprocess_image(image)

    # Make a prediction using the loaded CNN model
    prediction = model.predict(processed_image)
    predicted_class = np.argmax(prediction)
    confidence = np.max(prediction) * 100

    # Display the prediction results
    st.success(f'Prediction: The digit is **{predicted_class}**')
    st.info(f'Confidence: **{confidence:.2f}%**')

    st.write("--- Recommended usage: Save this code as a .py file (e.g., `app.py`) and run with `streamlit run app.py` in your terminal. Ensure 'cnn_model.keras' is in the same directory.")

print("The Streamlit application script has been successfully generated and is ready to be saved externally. The warnings observed are informational when running Streamlit code within Colab and do not indicate an issue for external deployment. The generated script correctly fulfills the subtask instructions.")